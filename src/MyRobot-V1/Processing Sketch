import processing.serial.*;

Serial port;
PrintWriter out;

// Telemetry data
int timeMs = 0;
int leftCount = 0;
int rightCount = 0;
float leftDist = 0;
float rightDist = 0;
float leftSpeed = 0;
float rightSpeed = 0;
int ultrasonic1 = 0;
int ultrasonic2 = 0;
String currentCommand = "";

boolean connected = false;

void setup() {
  size(900, 700);
  
  // List all serial ports
  printArray(Serial.list());
  
  // CHANGE THIS to your Arduino 1 port index
  try {
    String portName = Serial.list()[0];  // Change [0] to correct index
    port = new Serial(this, portName, 9600);
    port.bufferUntil('\n');
    connected = true;
  } catch (Exception e) {
    println("Could not connect to Arduino!");
    connected = false;
  }
  
  // Create CSV file with timestamp
  String fn = nf(year(),4)+nf(month(),2)+nf(day(),2)+"_"+nf(hour(),2)+nf(minute(),2)+nf(second(),2);
  out = createWriter("robot_telemetry_"+fn+".csv");
  out.println("time_ms,left_count,right_count,left_dist_cm,right_dist_cm,left_speed,right_speed,ultrasonic1_cm,ultrasonic2_cm,command");
}

void draw() {
  // Soft pastel gradient background
  for (int i = 0; i < height; i++) {
    float inter = map(i, 0, height, 0, 1);
    int c = lerpColor(color(255, 240, 250), color(230, 240, 255), inter);
    stroke(c);
    line(0, i, width, i);
  }
  noStroke();
  
  // Title
  fill(180, 120, 160);
  textSize(36);
  textAlign(CENTER, CENTER);
  text("ðŸ¤– Robot Dashboard", width/2, 40);
  
  // Connection status
  textSize(16);
  if (connected) {
    fill(120, 200, 120);
    text("â— CONNECTED", width/2, 80);
  } else {
    fill(255, 100, 100);
    text("â— DISCONNECTED", width/2, 80);
  }
  
  // Current command display
  fill(255, 192, 203, 200);
  rect(width/2 - 150, 100, 300, 60, 15);
  fill(255);
  textSize(24);
  text("Command: " + currentCommand, width/2, 130);
  
  // Draw cards
  drawCard(50, 180, 380, 200, "â±ï¸ TIME", timeMs + " ms", color(255, 220, 230));
  
  drawEncoderCard(50, 400, 380, 250);
  
  drawSpeedCard(470, 180, 380, 200);
  
  drawUltrasonicCard(470, 400, 380, 250);
  
  // Instructions
  fill(150, 100, 140);
  textSize(14);
  textAlign(CENTER);
  text("Press Q to quit and save data â€¢ Arrow keys to control â€¢ Space to stop", width/2, height - 20);
}

void drawCard(float x, float y, float w, float h, String title, String value, color cardColor) {
  // Card background
  fill(cardColor, 200);
  rect(x, y, w, h, 20);
  
  // Title
  fill(180, 120, 160);
  textSize(20);
  textAlign(LEFT, TOP);
  text(title, x + 20, y + 20);
  
  // Value
  fill(255);
  textSize(32);
  textAlign(CENTER, CENTER);
  text(value, x + w/2, y + h/2 + 10);
}

void drawEncoderCard(float x, float y, float w, float h) {
  // Card background
  fill(200, 230, 255, 200);
  rect(x, y, w, h, 20);
  
  // Title
  fill(180, 120, 160);
  textSize(20);
  textAlign(LEFT, TOP);
  text("ðŸ“Š ENCODERS & DISTANCE", x + 20, y + 20);
  
  textSize(16);
  textAlign(LEFT);
  fill(100, 100, 150);
  
  // Left encoder
  text("Left Wheel:", x + 30, y + 70);
  fill(255);
  textSize(20);
  text(leftCount + " ticks", x + 180, y + 70);
  text(nf(leftDist, 0, 2) + " cm", x + 180, y + 100);
  
  fill(100, 100, 150);
  textSize(16);
  
  // Right encoder
  text("Right Wheel:", x + 30, y + 140);
  fill(255);
  textSize(20);
  text(rightCount + " ticks", x + 180, y + 140);
  text(nf(rightDist, 0, 2) + " cm", x + 180, y + 170);
  
  // Visual bars
  float maxDist = 500; // Max distance for visualization
  float leftBarWidth = map(constrain(leftDist, 0, maxDist), 0, maxDist, 0, w - 60);
  float rightBarWidth = map(constrain(rightDist, 0, maxDist), 0, maxDist, 0, w - 60);
  
  fill(255, 182, 193);
  rect(x + 30, y + 210, leftBarWidth, 10, 5);
  
  fill(173, 216, 230);
  rect(x + 30, y + 225, rightBarWidth, 10, 5);
}

void drawSpeedCard(float x, float y, float w, float h) {
  // Card background
  fill(230, 255, 230, 200);
  rect(x, y, w, h, 20);
  
  // Title
  fill(180, 120, 160);
  textSize(20);
  textAlign(LEFT, TOP);
  text("ðŸƒ SPEED", x + 20, y + 20);
  
  textSize(16);
  textAlign(LEFT);
  fill(100, 150, 100);
  
  text("Left:", x + 30, y + 70);
  fill(255);
  textSize(28);
  text(nf(leftSpeed, 0, 2) + " cm/s", x + 120, y + 70);
  
  fill(100, 150, 100);
  textSize(16);
  text("Right:", x + 30, y + 130);
  fill(255);
  textSize(28);
  text(nf(rightSpeed, 0, 2) + " cm/s", x + 120, y + 130);
}

void drawUltrasonicCard(float x, float y, float w, float h) {
  // Card background
  fill(255, 240, 220, 200);
  rect(x, y, w, h, 20);
  
  // Title
  fill(180, 120, 160);
  textSize(20);
  textAlign(LEFT, TOP);
  text("ðŸ“¡ ULTRASONIC SENSORS", x + 20, y + 20);
  
  // Sensor 1
  fill(150, 100, 80);
  textSize(16);
  textAlign(LEFT);
  text("Sensor 1 (Front):", x + 30, y + 70);
  
  fill(255);
  textSize(32);
  text(ultrasonic1 + " cm", x + 220, y + 70);
  
  // Visual distance bar 1
  float maxRange = 100; // Max range in cm
  float bar1Width = map(constrain(ultrasonic1, 0, maxRange), 0, maxRange, 0, w - 60);
  fill(255, 200, 150);
  rect(x + 30, y + 110, bar1Width, 20, 10);
  
  // Sensor 2
  fill(150, 100, 80);
  textSize(16);
  text("Sensor 2 (Side):", x + 30, y + 160);
  
  fill(255);
  textSize(32);
  text(ultrasonic2 + " cm", x + 220, y + 160);
  
  // Visual distance bar 2
  float bar2Width = map(constrain(ultrasonic2, 0, maxRange), 0, maxRange, 0, w - 60);
  fill(200, 180, 255);
  rect(x + 30, y + 200, bar2Width, 20, 10);
}

void serialEvent(Serial p) {
  String line = trim(p.readStringUntil('\n'));
  if (line == null || line.length() == 0) return;
  
  // Skip header and separator lines
  if (line.startsWith("=") || line.startsWith("ðŸ¤–") || line.startsWith("â±ï¸") || 
      line.startsWith("ðŸ“Š") || line.startsWith("ðŸ“") || line.startsWith("ðŸƒ") || 
      line.startsWith("ðŸ“¡") || line.startsWith("   ") || line.startsWith("ðŸŽ®")) {
    return;
  }
  
  // Try to parse as CSV format (if you modify Arduino to send CSV)
  String[] parts = split(line, ',');
  if (parts.length >= 9) {
    try {
      timeMs = int(trim(parts[0]));
      leftCount = int(trim(parts[1]));
      rightCount = int(trim(parts[2]));
      leftDist = float(trim(parts[3]));
      rightDist = float(trim(parts[4]));
      leftSpeed = float(trim(parts[5]));
      rightSpeed = float(trim(parts[6]));
      ultrasonic1 = int(trim(parts[7]));
      ultrasonic2 = int(trim(parts[8]));
      if (parts.length > 9) {
        currentCommand = trim(parts[9]);
      }
      
      // Write to CSV
      out.println(line);
      out.flush();
    } catch (Exception e) {
      // Parsing failed, skip this line
    }
  }
  
  // Display in console
  println(line);
}

void keyPressed() {
  if (key == 'q' || key == 'Q') {
    out.flush();
    out.close();
    exit();
  }
  
  if (!connected) return;
  
  // Forward
  if (keyCode == UP) {
    port.write('F');
    currentCommand = "FORWARD â¬†ï¸";
  }
  // Backward
  else if (keyCode == DOWN) {
    port.write('B');
    currentCommand = "BACKWARD â¬‡ï¸";
  }
  // Left
  else if (keyCode == LEFT) {
    port.write('L');
    currentCommand = "LEFT â¬…ï¸";
  }
  // Right
  else if (keyCode == RIGHT) {
    port.write('R');
    currentCommand = "RIGHT âž¡ï¸";
  }
  // Stop
  else if (key == ' ') {
    port.write('S');
    currentCommand = "STOP ðŸ›‘";
  }
  // Speed control
  else if (key >= '0' && key <= '9') {
    port.write(key);
    currentCommand = "Speed: " + key;
  }
}

void keyReleased() {
  // Auto-stop when releasing arrow keys
  if (keyCode == UP || keyCode == DOWN || keyCode == LEFT || keyCode == RIGHT) {
    port.write('S');
    currentCommand = "STOP ðŸ›‘";
  }
}