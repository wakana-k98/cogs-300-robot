import processing.serial.*;

Serial port;
PrintWriter out;
String currentCommand = "STOPPED";
int currentSpeed = 5;
boolean connected = false;

// Button positions
int centerX, centerY;
int btnSize = 80;
int speedSliderX, speedSliderY;

void setup() {
  size(600, 800);
  centerX = width/2;
  centerY = 350;
  speedSliderX = 100;
  speedSliderY = 600;
  
  // List all serial ports
  printArray(Serial.list());
  
  // CHANGE THIS to your Arduino port index
  try {
    String portName = Serial.list()[2];  // Change [0] to correct index
    port = new Serial(this, portName, 9600);
    port.bufferUntil('\n');
    connected = true;
  } catch (Exception e) {
    println("Could not connect to Arduino!");
    connected = false;
  }
  
  // Create CSV file with timestamp
  String fn = nf(year(),4)+nf(month(),2)+nf(day(),2)+"_"+nf(hour(),2)+nf(minute(),2)+nf(second(),2);
  out = createWriter("robot_log_"+fn+".csv");
}

void draw() {
  // Soft gradient background
  for (int i = 0; i < height; i++) {
    float inter = map(i, 0, height, 0, 1);
    int c = lerpColor(color(255, 240, 245), color(230, 240, 255), inter);
    stroke(c);
    line(0, i, width, i);
  }
  
  // Title
  fill(180, 120, 160);
  textSize(32);
  textAlign(CENTER, CENTER);
  text("ðŸ¤– Robot Remote", centerX, 50);
  
  // Connection status
  textSize(16);
  if (connected) {
    fill(120, 200, 120);
    text("â— CONNECTED", centerX, 90);
  } else {
    fill(255, 100, 100);
    text("â— DISCONNECTED", centerX, 90);
  }
  
  // Current command display
  noStroke();
  fill(255, 245, 250, 200);
  rect(50, 120, width-100, 80, 15);
  
  fill(180, 120, 160);
  textSize(20);
  text("Current: " + currentCommand, centerX, 145);
  text("Speed: " + currentSpeed, centerX, 175);
  
  // Draw D-pad remote
  drawDPad();
  
  // Draw speed slider
  drawSpeedSlider();
  
  // Draw mode buttons
  drawModeButtons();
  
  // Instructions
  fill(150, 100, 140);
  textSize(14);
  text("Click buttons or use arrow keys â€¢ Space = Stop â€¢ Press Q to quit", centerX, height - 30);
}

void drawDPad() {
  // D-pad background circle
  noStroke();
  fill(255, 250, 255, 150);
  ellipse(centerX, centerY, 250, 250);
  
  // Center circle
  fill(255, 192, 203, 200);
  ellipse(centerX, centerY, 100, 100);
  fill(255);
  textSize(24);
  text("STOP", centerX, centerY);
  
  // UP button
  fill(isOverButton(centerX, centerY - 100, btnSize, btnSize) ? color(180, 220, 255) : color(173, 216, 230));
  rect(centerX - btnSize/2, centerY - 100 - btnSize/2, btnSize, btnSize, 10);
  fill(255);
  textSize(20);
  text("â†‘", centerX, centerY - 100);
  
  // DOWN button
  fill(isOverButton(centerX, centerY + 100, btnSize, btnSize) ? color(180, 220, 255) : color(173, 216, 230));
  rect(centerX - btnSize/2, centerY + 100 - btnSize/2, btnSize, btnSize, 10);
  fill(255);
  text("â†“", centerX, centerY + 100);
  
  // LEFT button
  fill(isOverButton(centerX - 100, centerY, btnSize, btnSize) ? color(180, 220, 255) : color(173, 216, 230));
  rect(centerX - 100 - btnSize/2, centerY - btnSize/2, btnSize, btnSize, 10);
  fill(255);
  text("â†", centerX - 100, centerY);
  
  // RIGHT button
  fill(isOverButton(centerX + 100, centerY, btnSize, btnSize) ? color(180, 220, 255) : color(173, 216, 230));
  rect(centerX + 100 - btnSize/2, centerY - btnSize/2, btnSize, btnSize, 10);
  fill(255);
  text("â†’", centerX + 100, centerY);
}

void drawSpeedSlider() {
  // Speed control background
  noStroke();
  fill(255, 245, 250, 200);
  rect(50, speedSliderY - 40, width - 100, 120, 15);
  
  fill(180, 120, 160);
  textSize(18);
  textAlign(CENTER);
  text("SPEED CONTROL", centerX, speedSliderY - 10);
  
  // Slider track
  fill(220, 200, 220);
  rect(speedSliderX, speedSliderY + 20, width - 200, 20, 10);
  
  // Slider handle
  float sliderPos = map(currentSpeed, 0, 9, speedSliderX, speedSliderX + width - 200);
  fill(255, 182, 193);
  stroke(255);
  strokeWeight(2);
  ellipse(sliderPos, speedSliderY + 30, 40, 40);
  
  // Speed numbers
  noStroke();
  fill(150, 100, 140);
  textSize(14);
  for (int i = 0; i <= 9; i++) {
    float x = map(i, 0, 9, speedSliderX, speedSliderX + width - 200);
    text(i, x, speedSliderY + 65);
  }
}

void drawModeButtons() {
  textAlign(CENTER, CENTER);
  textSize(16);
  
  // Manual mode button
  float manBtnX = width/2 - 100;
  float manBtnY = 700;
  fill(isOverButton(manBtnX, manBtnY, 140, 50) ? color(200, 240, 200) : color(180, 248, 200));
  rect(manBtnX - 70, manBtnY - 25, 140, 50, 10);
  fill(255);
  text("MANUAL", manBtnX, manBtnY);
  
  // Auto mode button
  float autoBtnX = width/2 + 100;
  float autoBtnY = 700;
  fill(isOverButton(autoBtnX, autoBtnY, 140, 50) ? color(255, 220, 180) : color(255, 200, 150));
  rect(autoBtnX - 70, autoBtnY - 25, 140, 50, 10);
  fill(255);
  text("AUTO", autoBtnX, autoBtnY);
}

boolean isOverButton(float x, float y, float w, float h) {
  return mouseX > x - w/2 && mouseX < x + w/2 && 
         mouseY > y - h/2 && mouseY < y + h/2;
}

void serialEvent(Serial p) {
  String line = trim(p.readStringUntil('\n'));
  if (line == null || line.length() == 0) return;
  
  // Write telemetry to CSV
  out.println(line);
  out.flush();
  
  // Display in console
  println(line);
}

void mousePressed() {
  if (!connected) return;
  
  // D-pad buttons
  if (isOverButton(centerX, centerY - 100, btnSize, btnSize)) {
    sendCommand('F', "FORWARD");
  }
  else if (isOverButton(centerX, centerY + 100, btnSize, btnSize)) {
    sendCommand('B', "BACKWARD");
  }
  else if (isOverButton(centerX - 100, centerY, btnSize, btnSize)) {
    sendCommand('L', "LEFT");
  }
  else if (isOverButton(centerX + 100, centerY, btnSize, btnSize)) {
    sendCommand('R', "RIGHT");
  }
  else if (dist(mouseX, mouseY, centerX, centerY) < 50) {
    sendCommand('S', "STOP");
  }
  
  // Mode buttons
  if (isOverButton(width/2 - 100, 700, 140, 50)) {
    sendCommand('M', "MANUAL MODE");
  }
  else if (isOverButton(width/2 + 100, 700, 140, 50)) {
    sendCommand('A', "AUTO MODE");
  }
  
  // Speed slider
  if (mouseY > speedSliderY + 10 && mouseY < speedSliderY + 50 &&
      mouseX > speedSliderX && mouseX < speedSliderX + width - 200) {
    int newSpeed = int(map(mouseX, speedSliderX, speedSliderX + width - 200, 0, 9));
    currentSpeed = constrain(newSpeed, 0, 9);
    sendCommand(char('0' + currentSpeed), "Speed: " + currentSpeed);
  }
}

void mouseDragged() {
  // Allow dragging the speed slider
  if (mouseY > speedSliderY && mouseY < speedSliderY + 80 &&
      mouseX > speedSliderX && mouseX < speedSliderX + width - 200) {
    int newSpeed = int(map(mouseX, speedSliderX, speedSliderX + width - 200, 0, 9));
    if (newSpeed != currentSpeed) {
      currentSpeed = constrain(newSpeed, 0, 9);
      sendCommand(char('0' + currentSpeed), "Speed: " + currentSpeed);
    }
  }
}

void mouseReleased() {
  // Auto-stop when releasing direction buttons (optional)
  if (isOverButton(centerX, centerY - 100, btnSize, btnSize) ||
      isOverButton(centerX, centerY + 100, btnSize, btnSize) ||
      isOverButton(centerX - 100, centerY, btnSize, btnSize) ||
      isOverButton(centerX + 100, centerY, btnSize, btnSize)) {
    sendCommand('S', "STOP");
  }
}

void keyPressed() {
  if (!connected) return;
  
  if (key == 'q' || key == 'Q') {
    out.flush();
    out.close();
    exit();
  }
  
  // Arrow keys
  if (keyCode == UP) {
    sendCommand('F', "FORWARD");
  }
  else if (keyCode == DOWN) {
    sendCommand('B', "BACKWARD");
  }
  else if (keyCode == LEFT) {
    sendCommand('L', "LEFT");
  }
  else if (keyCode == RIGHT) {
    sendCommand('R', "RIGHT");
  }
  else if (key == ' ') {
    sendCommand('S', "STOP");
  }
  // Speed numbers
  else if (key >= '0' && key <= '9') {
    currentSpeed = int(str(key));
    sendCommand(key, "Speed: " + currentSpeed);
  }
  // Mode controls
  else if (key == 'm' || key == 'M') {
    sendCommand('M', "MANUAL MODE");
  }
  else if (key == 'a' || key == 'A') {
    sendCommand('A', "AUTO MODE");
  }
}

void keyReleased() {
  // Auto-stop when releasing arrow keys (optional)
  if (keyCode == UP || keyCode == DOWN || keyCode == LEFT || keyCode == RIGHT) {
    sendCommand('S', "STOP");
  }
}

void sendCommand(char cmd, String display) {
  if (connected) {
    port.write(cmd);
    currentCommand = display;
  }
}