#include <WiFiS3.h>


// ========== HOTSPOT CREDENTIALS ==========
const char* ssid = "Brady";        // Replace with your hotspot name
const char* password = "Brady2005";     // Replace with your hotspot password


WiFiServer server(80);  // Web server on port 80


// ========== MOTOR PINS ==========
int enA = 9;
int in1 = 8;
int in2 = 7;
int enB = 10;
int in3 = 12;
int in4 = 13;
int speed = 200;


// Motor trim (adjust these to fix veering)
float leftTrim = 0.7;
float rightTrim = 1.0;


// ========== ULTRASONIC SENSOR 1 (FRONT) ==========
const int trigPin1 = 3;
const int echoPin1 = 4;
long duration1, cm1;


// ========== ULTRASONIC SENSOR 2 (RIGHT SIDE) ==========
const int trigPin2 = 5;
const int echoPin2 = 6;
long duration2, cm2;


// ========== AUTONOMOUS MODE ==========
bool autonomousMode = false;  // Start in manual mode
int baseSpeed = 200;          // Full speed
int currentSpeed = 200;
int turnDuration90 = 300;     // Time for 90-degree turn (adjust this value!)

// Wall following parameters (ADJUSTABLE)
int targetWallDistance = 15;   // Target distance from right wall in cm
int wallToleranceLow = 25;     // Lower bound (closer than this = steer away)
int wallToleranceHigh = 35;    // Upper bound (farther than this = steer toward)
int wallLostDistance = 40;     // Distance where we consider wall "lost"

// Outside corner detection
unsigned long wallLostTime = 0;
bool wallWasPresent = false;
const int cornerTurnDuration = 800;  // How long to turn right at outside corner

// Non-blocking timing for post-turn forward movement
unsigned long forwardStartTime = 0;
bool isMovingForward = false;
const int forwardDuration = 500;  // Reduced from 800 for faster wall re-acquisition


void setup() {
 // Motor setup
 pinMode(enA, OUTPUT);
 pinMode(in1, OUTPUT);
 pinMode(in2, OUTPUT);
 pinMode(enB, OUTPUT);
 pinMode(in3, OUTPUT);
 pinMode(in4, OUTPUT);


 // MAKE SURE MOTORS START STOPPED
 digitalWrite(in1, LOW);
 digitalWrite(in2, LOW);
 digitalWrite(in3, LOW);
 digitalWrite(in4, LOW);
 analogWrite(enA, 0);
 analogWrite(enB, 0);


 // Ultrasonic 1 setup
 pinMode(trigPin1, OUTPUT);
 pinMode(echoPin1, INPUT);


 // Ultrasonic 2 setup
 pinMode(trigPin2, OUTPUT);
 pinMode(echoPin2, INPUT);


 Serial.begin(9600);
 delay(2000);
  Serial.println("========================================");
 Serial.println("ROBOT CONTROL - Wall Following Mode");
 Serial.println("========================================");
 Serial.println();


 // Connect to Hotspot
 Serial.print("Connecting to hotspot: ");
 Serial.println(ssid);
  WiFi.begin(ssid, password);
  int attempts = 0;
 while (WiFi.status() != WL_CONNECTED && attempts < 40) {
   delay(500);
   Serial.print(".");
   attempts++;
 }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
   Serial.println("Connected to Hotspot!");
   Serial.println();
   Serial.println("========================================");
   Serial.print("IP Address: ");
   Serial.println(WiFi.localIP());
   Serial.println("========================================");
   Serial.println();
  
   server.begin();
 } else {
   Serial.println("Failed to connect to hotspot");
 }
}


void loop() {
 // ========== READ ULTRASONIC SENSORS CONTINUOUSLY ==========
 // Read Sensor 1 (FRONT)
 digitalWrite(trigPin1, LOW);
 delayMicroseconds(2);
 digitalWrite(trigPin1, HIGH);
 delayMicroseconds(10);
 digitalWrite(trigPin1, LOW);
  duration1 = pulseIn(echoPin1, HIGH, 30000);  // 30ms timeout
 cm1 = (duration1 == 0) ? 999 : (duration1 / 2) / 29.1;  // 999 = no obstacle


 delayMicroseconds(10);


 // Read Sensor 2 (RIGHT SIDE)
 digitalWrite(trigPin2, LOW);
 delayMicroseconds(2);
 digitalWrite(trigPin2, HIGH);
 delayMicroseconds(10);
 digitalWrite(trigPin2, LOW);
  duration2 = pulseIn(echoPin2, HIGH, 30000);  // 30ms timeout
 cm2 = (duration2 == 0) ? 999 : (duration2 / 2) / 29.1;  // 999 = no obstacle


 // ========== AUTONOMOUS DRIVING LOGIC ==========
 if (autonomousMode) {
   // If we're in a timed forward move after a turn
   if (isMovingForward) {
     if (millis() - forwardStartTime < forwardDuration) {
       // Continue forward but STILL CHECK for obstacles
       if (cm1 > 0 && cm1 <= 30) {
         // New wall detected during post-turn forward - abort and handle it
         Serial.println("AUTO: New wall detected during post-turn forward!");
         isMovingForward = false;
       } else {
         // Keep moving forward with wall following
         followWall();
       }
     } else {
       // Forward duration complete
       isMovingForward = false;
     }
   }
   
   // Normal wall-following logic (only when not in timed forward move)
   if (!isMovingForward) {
     // ========== FRONT WALL DETECTION (Priority) ==========
     if (cm1 > 0 && cm1 <= 30) {
       // Wall very close at 30cm, stop and turn
       Serial.print("AUTO: Front wall detected at ");
       Serial.print(cm1);
       Serial.println(" cm - stopping");
       
       // STOP
       driveAutonomous(LOW, LOW, LOW, LOW, 0);
       delay(300);
       
       // Always turn LEFT 90 degrees when hitting front wall
       Serial.println("AUTO: Turning LEFT 90 degrees");
       driveAutonomous(HIGH, LOW, LOW, HIGH, baseSpeed);
       delay(turnDuration90);
       
       // Stop after turn
       driveAutonomous(LOW, LOW, LOW, LOW, 0);
       delay(200);
       
       // Start timed forward movement (non-blocking)
       Serial.println("AUTO: Moving forward after turn");
       isMovingForward = true;
       forwardStartTime = millis();
       wallWasPresent = false;  // Reset wall tracking
     }
     // ========== NO FRONT WALL - USE WALL FOLLOWING ==========
     else {
       followWall();
     }
   }
 }


 // ========== HANDLE WIFI CLIENTS ==========
 WiFiClient client = server.available();
  if (client) {
   String currentLine = "";
  
   while (client.connected()) {
     if (client.available()) {
       char c = client.read();
      
       if (c == '\n') {
         if (currentLine.length() == 0) {
           // Send HTTP response
           sendWebPage(client);
           break;
         } else {
           // Process GET request
           if (currentLine.indexOf("GET /AUTO_ON") >= 0) {
             autonomousMode = true;
             wallWasPresent = false;
             Serial.println("AUTONOMOUS MODE: ON");
           }
           else if (currentLine.indexOf("GET /AUTO_OFF") >= 0) {
             autonomousMode = false;
             drive(LOW, LOW, LOW, LOW);  // Stop
             Serial.println("AUTONOMOUS MODE: OFF");
           }
           else if (currentLine.indexOf("GET /F") >= 0 && !autonomousMode) {
             Serial.println("MANUAL: FORWARD");
             drive(LOW, HIGH, LOW, HIGH);
           }
           else if (currentLine.indexOf("GET /B") >= 0 && !autonomousMode) {
             Serial.println("MANUAL: BACKWARD");
             drive(HIGH, LOW, HIGH, LOW);
           }
           else if (currentLine.indexOf("GET /L") >= 0 && !autonomousMode) {
             Serial.println("MANUAL: LEFT");
             drive(HIGH, LOW, LOW, HIGH);
           }
           else if (currentLine.indexOf("GET /R") >= 0 && !autonomousMode) {
             Serial.println("MANUAL: RIGHT");
             drive(LOW, HIGH, HIGH, LOW);
           }
           else if (currentLine.indexOf("GET /S") >= 0 && !autonomousMode) {
             Serial.println("MANUAL: STOP");
             drive(LOW, LOW, LOW, LOW);
           }
           else if (currentLine.indexOf("GET /data") >= 0) {
             // Send JSON telemetry data
             sendTelemetryJSON(client);
             client.stop();
             return;
           }
           currentLine = "";
         }
       } else if (c != '\r') {
         currentLine += c;
       }
     }
   }
   client.stop();
 }


 delay(5);  // Faster sensor updates for better response time
}


// ========== WALL FOLLOWING FUNCTION ==========
void followWall() {
 int rightDistance = cm2;
 
 // ========== OUTSIDE CORNER DETECTION ==========
 // If we previously had a wall and now it's gone, we hit an outside corner
 if (wallWasPresent && (rightDistance >= wallLostDistance || rightDistance == 999)) {
   if (wallLostTime == 0) {
     // Wall just disappeared - mark the time
     wallLostTime = millis();
     Serial.println("AUTO: Wall lost - outside corner detected!");
   }
   
   // If wall has been lost for more than 200ms, turn right to follow the corner
   if (millis() - wallLostTime > 0) {
     Serial.println("AUTO: Turning RIGHT to follow outside corner");
     
     // Turn right for cornerTurnDuration
     driveAutonomous(LOW, HIGH, HIGH, LOW, baseSpeed);
     delay(cornerTurnDuration);
     
     // Reset wall tracking
     wallWasPresent = false;
     wallLostTime = 0;
     
     // Brief stop
     driveAutonomous(LOW, LOW, LOW, LOW, 0);
     delay(100);
     
     return;  // Exit function, will check sensors again next loop
   }
 }
 else if (rightDistance < wallLostDistance && rightDistance != 999) {
   // Wall is present - reset the lost timer
   wallLostTime = 0;
   wallWasPresent = true;
 }
 
 // ========== NORMAL WALL FOLLOWING ==========
 // No wall on right - search for wall by going straight
 if (rightDistance >= wallLostDistance || rightDistance == 999) {
   currentSpeed = baseSpeed;
   driveAutonomous(LOW, HIGH, LOW, HIGH, currentSpeed);
   Serial.println("AUTO: No wall detected - searching");
 }
 // Wall is TOO CLOSE - steer LEFT (away from wall)
 else if (rightDistance < wallToleranceLow) {
   Serial.print("AUTO: Too close (");
   Serial.print(rightDistance);
   Serial.println(" cm) - steering LEFT");
   
   // Steer left by slowing right motor
   digitalWrite(in1, LOW);
   digitalWrite(in2, HIGH);
   analogWrite(enA, baseSpeed * leftTrim);  // Left motor full speed
   
   digitalWrite(in3, LOW);
   digitalWrite(in4, HIGH);
   analogWrite(enB, (baseSpeed * 0.5) * rightTrim);  // Right motor 50% speed
   driveAutonomous(LOW, HIGH, LOW, HIGH, baseSpeed);
 }
 // Wall is TOO FAR - steer RIGHT (toward wall)
 else if (rightDistance > wallToleranceHigh) {
   Serial.print("AUTO: Too far (");
   Serial.print(rightDistance);
   Serial.println(" cm) - steering RIGHT");
   
   // Steer right by slowing left motor
   digitalWrite(in1, LOW);
   digitalWrite(in2, HIGH);
   analogWrite(enA, (baseSpeed * 0.5) * leftTrim);  // Left motor 50% speed
   
   digitalWrite(in3, LOW);
   digitalWrite(in4, HIGH);
   analogWrite(enB, baseSpeed * rightTrim);  // Right motor full speed
   driveAutonomous(LOW, HIGH, LOW, HIGH, baseSpeed);
 }
 // Wall is PERFECT - go straight at target distance
 else {
   currentSpeed = baseSpeed;
   driveAutonomous(LOW, HIGH, LOW, HIGH, currentSpeed);
   Serial.print("AUTO: Perfect distance (");
   Serial.print(rightDistance);
   Serial.println(" cm) - straight");
 }
}


// ========== DRIVE FUNCTION (Manual Control) ==========
void drive(int a1, int a2, int b1, int b2) {
 digitalWrite(in1, a1);
 digitalWrite(in2, a2);
 analogWrite(enA, (a1 == a2) ? 0 : speed * leftTrim);


 digitalWrite(in3, b2);
 digitalWrite(in4, b1);
 analogWrite(enB, (b1 == b2) ? 0 : speed * rightTrim);
}


// ========== DRIVE FUNCTION (Autonomous Control with Speed) ==========
void driveAutonomous(int a1, int a2, int b1, int b2, int autoSpeed) {
 digitalWrite(in1, a1);
 digitalWrite(in2, a2);
 analogWrite(enA, (a1 == a2) ? 0 : autoSpeed * leftTrim);


 digitalWrite(in3, b2);
 digitalWrite(in4, b1);
 analogWrite(enB, (b1 == b2) ? 0 : autoSpeed * rightTrim);
}


// ========== SEND WEB PAGE ==========
void sendWebPage(WiFiClient &client) {
 client.println("HTTP/1.1 200 OK");
 client.println("Content-type:text/html");
 client.println();
  // HTML page with controls
 client.println("<!DOCTYPE html>");
 client.println("<html>");
 client.println("<head>");
 client.println("<meta name='viewport' content='width=device-width, initial-scale=1'>");
 client.println("<title>Robot Control</title>");
 client.println("<style>");
 client.println("body { font-family: Arial; text-align: center; background: #1e1e1e; color: #fff; margin: 0; padding: 20px; }");
 client.println("h1 { color: #4CAF50; font-size: 32px; }");
 client.println(".mode-section { margin: 20px auto; max-width: 400px; }");
 client.println(".mode-btn { background: #2196F3; border: none; color: white; padding: 20px 40px; font-size: 20px; font-weight: bold; margin: 10px; cursor: pointer; border-radius: 10px; width: 200px; }");
 client.println(".mode-btn.active { background: #ff9800; }");
 client.println(".mode-btn:active { transform: scale(0.95); }");
 client.println(".controls { margin: 30px auto; max-width: 400px; }");
 client.println(".btn { background: #4CAF50; border: none; color: white; padding: 15px 25px; font-size: 18px; font-weight: bold; margin: 8px; cursor: pointer; border-radius: 10px; min-width: 120px; }");
 client.println(".btn:active { background: #45a049; transform: scale(0.95); }");
 client.println(".btn:disabled { background: #555; cursor: not-allowed; }");
 client.println(".stop { background: #f44336; font-size: 20px; }");
 client.println(".stop:active { background: #da190b; }");
 client.println(".row { display: flex; justify-content: center; margin: 10px 0; }");
 client.println(".telemetry { background: #2d2d2d; padding: 20px; margin: 30px auto; max-width: 400px; border-radius: 10px; }");
 client.println(".sensor { margin: 15px 0; font-size: 20px; font-weight: bold; }");
 client.println(".sensor-label { color: #4CAF50; }");
 client.println(".sensor-value { color: #fff; font-size: 24px; }");
 client.println(".status { font-size: 18px; margin: 20px 0; padding: 15px; background: #333; border-radius: 8px; }");
 client.println("</style>");
 client.println("</head>");
 client.println("<body>");
 client.println("<h1>Robot Control</h1>");
  // Mode Selection
 client.println("<div class='mode-section'>");
 client.println("<h2 style='color: #2196F3;'>Control Mode</h2>");
 client.println("<button class='mode-btn' id='autoBtn' onclick='setAuto(true)'>AUTONOMOUS</button>");
 client.println("<button class='mode-btn active' id='manualBtn' onclick='setAuto(false)'>MANUAL</button>");
 client.println("<div class='status' id='status'>Mode: Manual Control</div>");
 client.println("</div>");
  // Manual Controls
 client.println("<div class='controls' id='manualControls'>");
 client.println("<div class='row'><button class='btn' onclick='send(\"F\")'>FORWARD</button></div>");
 client.println("<div class='row'>");
 client.println("<button class='btn' onclick='send(\"L\")'>LEFT</button>");
 client.println("<button class='btn stop' onclick='send(\"S\")'>STOP</button>");
 client.println("<button class='btn' onclick='send(\"R\")'>RIGHT</button>");
 client.println("</div>");
 client.println("<div class='row'><button class='btn' onclick='send(\"B\")'>BACK</button></div>");
 client.println("</div>");
  // Sensor Telemetry
 client.println("<div class='telemetry'>");
 client.println("<h2 style='color: #4CAF50; margin-top: 0;'>Sensor Readings</h2>");
 client.println("<div class='sensor'><span class='sensor-label'>Front Sensor:</span> <span class='sensor-value' id='s1'>--</span> cm</div>");
 client.println("<div class='sensor'><span class='sensor-label'>Right Sensor:</span> <span class='sensor-value' id='s2'>--</span> cm</div>");
 client.println("<div style='margin-top: 20px; padding: 10px; background: #3d3d3d; border-radius: 5px;'>");
 client.println("<div style='color: #2196F3; font-size: 16px; margin-bottom: 10px;'>Wall Following Settings</div>");
 client.println("<div style='font-size: 14px; color: #aaa;'>Target: 30cm | Range: 25-35cm</div>");
 client.println("<div style='font-size: 12px; color: #888; margin-top: 5px;'>Handles outside corners automatically</div>");
 client.println("</div>");
 client.println("</div>");
  client.println("<script>");
 client.println("let autoMode = false;");
 client.println("function send(cmd) { fetch('/' + cmd); }");
 client.println("function setAuto(mode) {");
 client.println("  autoMode = mode;");
 client.println("  if (mode) {");
 client.println("    fetch('/AUTO_ON');");
 client.println("    document.getElementById('status').textContent = 'Mode: Right-Wall Following (30cm target)';");
 client.println("    document.getElementById('status').style.background = '#ff9800';");
 client.println("    document.getElementById('autoBtn').classList.add('active');");
 client.println("    document.getElementById('manualBtn').classList.remove('active');");
 client.println("    document.getElementById('manualControls').style.opacity = '0.3';");
 client.println("  } else {");
 client.println("    fetch('/AUTO_OFF');");
 client.println("    document.getElementById('status').textContent = 'Mode: Manual Control';");
 client.println("    document.getElementById('status').style.background = '#333';");
 client.println("    document.getElementById('autoBtn').classList.remove('active');");
 client.println("    document.getElementById('manualBtn').classList.add('active');");
 client.println("    document.getElementById('manualControls').style.opacity = '1';");
 client.println("  }");
 client.println("}");
 client.println("setInterval(() => {");
 client.println("  fetch('/data').then(r => r.json()).then(d => {");
 client.println("    document.getElementById('s1').textContent = d.s1 === 999 ? 'No obstacle' : d.s1;");
 client.println("    document.getElementById('s2').textContent = d.s2 === 999 ? 'No obstacle' : d.s2;");
 client.println("  }).catch(e => console.log('Error fetching data'));");
 client.println("}, 500);");
 client.println("</script>");
  client.println("</body></html>");
}


// ========== SEND TELEMETRY JSON ==========
void sendTelemetryJSON(WiFiClient &client) {
 client.println("HTTP/1.1 200 OK");
 client.println("Content-type:application/json");
 client.println();
 client.print("{\"s1\":");
 client.print(cm1);
 client.print(",\"s2\":");
 client.print(cm2);
 client.print(",\"mode\":\"");
 client.print(autonomousMode ? "auto" : "manual");
 client.println("\"}");
}